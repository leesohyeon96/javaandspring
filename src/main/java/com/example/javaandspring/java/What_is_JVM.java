package com.example.javaandspring.java;

public class What_is_JVM {

    // 1. JVM이란?
    // - java virtual machine 의 줄임말
    // - java를 실행시키기 위한 가상 기계(=컴퓨터)
    // -> java는 OS에 종속적이지 않은데 이걸 도와주는 것이 JVM이고 JVM은 OS상 위에서 동작함

        // 1-1. 컴파일
        // - java 소스코드는 CPU가 인식하지 못한다. 그래서 뭔가를 해줘야 하는데 그것이 컴파일이고
        //   이때, java는 JVM이라는 가상머신을 거쳐서 OS에 도달하기 때문에 OS가 인식할 수 있는 기계어로
        //        바로 컴파일 되는 것이 아니라 JVM이 인식할 수 있는 Java bytecode(.class)로 변환됨!(ㅇㅎ)
        // - 즉, java compiler가 .java -> .class 파일로 변환시킴
        // - 그리고 이 변환된 bytecode를 JVM이 OS가 이해할 수 있도록 해석해줌

        // 1-2. Java Compiler
        // - 자바 컴파일러는 JDK를 설치하면 javac.exe 라는 실행파일 형태로 설치됨
        // - 구체적으로, JDK의 'bin폴더'에 javac.exe로 존재함
        // - 자바 컴파일러의 'javac'라는 명령어를 사용하면 .class 파일을 생성할 수 있음

        // 1-3. 바이트코드(byte code)란?
        // - 가상 컴퓨터(VM)에 돌아가는 실행 프로그램을 위한 이진 표기법(ㅈㅇ)
        // - 자바 컴파일러에 의해 변환된 코드의 명령어 크기가 -> 1 byte 라서 '자바 바이트 코드'라고 불리고 있음
        // - 이 바이트 코드는 다시 '실시간 번역기' or 'JIT(Just-In-Time) 컴파일러'에 의해 '바이너리(binary)코드'로 변환됨(ㅈㅇ)

            // 1-3-1. 바이너리 코드(= 이진 코드)
            // - 컴퓨터가 이해할 수 있는 0과 1로 이루어진 이진코드

            // 1-3-2. JIT(= 동적번역)란?
            // - 런타임 시 바이트 코드를 -> 원시 시스템 코드로 컴파일하여 java 어플리케이션의 성능을 향상시키는 런타임 환경의 컴포넌트
            // [참고] JVM에는 JIT(컴파일러?) 라는 것이 있고 함수로 자주 호출되면 JIT 호출 임계치를 넘는데 이때 jvm cache에 들어가서 호출 속도가 빨라지게 됨
            //-> 그래서 static 객체의 경우 생성자를 생성하지 않고 private 형태로 생성하는 걸지두..? (함숯형태..?)
            //[확실 ㄴㄴ]
            // - 인터프리터 방식의 단점을 보완해줌 -> 인터프리터 방식으로 실행하다가 적절한 시점에 바이트 코드 전체를 '컴파일'하여 기계어로 변경 후 더 이상 인터프리팅 하지 않고 기계어로 직접 실행하는 방식!
            // - 기계어(컴파일된 코드)는 '캐시'에 보관하기 때문에 한 번 컴파일된 코드는 빠르게 수행됨
            // - 즉, 한번만 실행되는 코드라면 컴파일 말고 인터프리팅하는게 더 이득

            // [결론]
            // - 자바 컴파일러가 .java > .class(바이트 코드)로 변환한다음
            //   런타임시에 JVM이(정확히는 JRE) 바이트 코드를 -> JIT 컴파일러를 통해 '기계어'로 변환함

        // 1-4. JVM의 메모리 구조(-> 구성요소?)
        //- 클래스 로더(Class Loader) -> JVM 내로 클래스 파일을 로드하고 링크를 통해 배치하는 작업을 수행하는 모듈
        //                             Loading/Linking/Initialization
        //                          -> 런타임시 동적으로 클래스를 로드하고 jar 파일 내 저장된 클래스들을 JVM 위에 탑재함
        //                          -> '클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크하는 역할!'
        //- 실행 엔진(Execution Engine) -> 클래스를 실행시키는 역할
        //                               (위의 클래스 로더가 JVM내의 런타임 데이터 영역에 바이트 코드를 배치시키고 이걸 실행엔진이 실행시킴!)
            //- 인터프리터(Interpreter) -> 자바 바이트 코드를 명령어 단위로 읽어서 실행, 한줄씩 수행해서 느림
            //- JIT 컴파일러(Just-in-Time) -> 인터프리터 방식으로 실행하다가 적절한 시점에 바이트 코드 전체를 컴파일 하여 기계어로(바이너리 코드?) 변경 후, 이후에 더 이상 인터프리팅 하지 않고 기계어로 직접 실행
            //- 가비지 콜렉터(Garbage collector) -> 더 이상 사용되지 않는 인스턴스를 찾아 메모리에서 삭제함
        //- 런타임 데이터 영역 (Runtime Data Area) -> 프로그램을 수행하기 위해 OS에서 할당받는 메모리 공간
            // - Heap/Method/여러개의Thread(그 내부에 여러개의Stack) => Heap, Method 영역은 모든 스레드들이 공유함
            //                                                  스레드마다 PC Register, Native Method Stack이 생성되며 스레드가 종료될 때 사라짐
            //                                                  모든 스레드들이 실행 후 종료되면 Heap, Method 영역도 종료됨
            // -> PC Register : Thread가 시작될 때 생성되며 > 생성될 때마다 생성되는 공간, 스레드마다 1개씩 존재!
            //                  Thread가 어떤 부분을 어떤 명령으로 실행해야할 지에 대한 기록을 하는 부분 + [*JVM이 현재 수행 중인 명령어의 주소를 가짐]
            // -> Stack : Frame 이라는 자료구조를 저장 + C 같은 전통적인 언어의 스택구조와 비슷(지역변수, 함수의 실행결과를 저장하며 함수 호출/반환을 담당 -> 내가 아는 그 스택임ㅇㅇ)
            //          - Frame : 데이터, 반환 값을 저장하는 자료구조
            // -> Native Method Stack : 다른 언어로 작성된 코드를 실행할 때 사용되는 스택
            // -> Heap : 클래스의 인스턴스들(객체)과 배열들이 저장되는 공간 + 가비지 컬렉션이라는 동적 메모리 관리 시스템에 의해 관리됨
            // -> Method : 런타임 상수, 풀, 필드, 함수, 코드 등 클래스와 인터페이스의 구조가 저장되는 공간
            //          - Runtime Constant Pool : 클래스, 인터페이스마다 존재하며 클래스 파일의 Constant pool 테이블 영역이 저장되는 공간
            //

    // 2. JDK란?
    // - Java Development Kit(자바 개발 키트)
    // - *Java를 사용하기 위해 필요한 '모든 기능을 갖춘 Java용 SDK(Software Development Kit)임!)
    // - JDK = JRE + JVM
    // - JRE = JVM + 클래스 라이브러리들
        // - SDK란? -> 하드웨어플랫폼/운영체제/프로그래밍언어제작사가 제공하는 '툴' + SDK를 활용하여 '애플리케이션 개발'할 수 있음!

    // 3. 자바가 동작하는 원리(= 자바 프로그램 실행과정)
    // - 1. java code(.java)가 javac Compiler에 의해 Byte Code(.class)로 변환된다.
    // - 2. JVM 메모리 구조 중 하나인 Execution Engine에 의해 [인터프리터 + JIT 컴파일러] Native Code(아마 바이너리 코드인듯)로 변환되어 실행된다.
    // -> 자세한 것은 JVM 명세에 작성되지 않음(WHY? 창의력을 저해시킬 수 있어서 명시하지 않았다고 함)


    // 4. stack, heap, static
    // - static -> 클래스 정보를 처음 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간
    //          - Runtime Constant Pool -> 스태틱 영역에 존재하는 별도의 관리영역!
    //                                     '상수 자료형'을 저장하여 참조 && 중복을 막는 역할
    //          - 스태틱에 저장되는 데이터 -> 멤버 변수, 메소드, 타입(interface or object는 제외 - heap에서 관리)
    // - heap -> 객체를 저장하는 가상 메모리 공간, new 연산자로 생성되는 객체/배열을 저장
    //          - Permanent Generation -> '생성된 객체들의 주소값들이 저장된 공간' + '클래스 로더에 의해 로드된 Class, Method 등에 대한 Meta 정보가 저장되는 영역이고 JVM에 의해 사용됨
    //                                     Reflection을 사용하여 동적으로 클래스가 로드되는 경우에 사용됨
    //              ** - Reflection이란? -> '객체를 통해 클래스의 정보를 분석'해내는 프로그래밍 기법
    //                                      구체적인 클래스 타입을 알지 못해도, 컴파일된 바이트 코드를 통해 역으로 클래스의 정보를 알아내어 사용할 수 있음!
    //          - New/Young 영역 -> 이곳의 인스턴스들은 추후 가비지 콜렉터에 의해 사라짐 + 생명 주기가 짧은 '젊은 객체'를 GC대상으로 하는 영역
    //          - Old 영역 -> 인스턴스들은 추후 가비지 콜렉터에 의해 사라짐 + 생명 주기가 긴 '오래된 객체'를 GC 대상으로 하는 영역
}
